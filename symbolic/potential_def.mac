/*-----------------------------------------------------------------------------
Writing of potentials, their derivatives, and electromagnetic tensor Fem1
to fortran source code

Directions: write a maxima script with the potentials using the variables
defined below. After defining everything, call the function write_pot_fortran()
to calculate and write.
------------------------------------------------------------------------------*/

print("
--- -- -- -- ---._      UJTI - general geodesic ray-tracer
                o `.                                   o     _
                    \\          Cinespa UCR 2019  *  ( ) GANDREOLIVA.org
=======================================================================
  Symbolic metric in Maxima --> Potentials, derivatives, and Fem1
  for the Fortran numeric modules.
-----------------------------------------------------------------------
")$

print("Coordinate names: t,r,th,ph,")$
print("Potential names: pv,pw,px,py,pz,At,Aph")$
print("The potentials can only depend on r and th")$
print("Parameters: put (lowercase) symbols in a list called metric_parameters")$
print("Name of the metric : metric_name")$
print("Name of the electromagnetic potential : electromagneticpotential_name")$
print("Output dir: dir (default: '', working directory)")$
print("-----------------------------------------------------------------------")$

dir : "" $

/* Fortran code that wraps up the metric potentials, derivs, and Fem1 in a module */

code1 :
" use, intrinsic :: iso_fortran_env, dp=>real64
 implicit none"$

code2 :
"  save
contains
  function get_potential(pos) result(pot)
    real(dp), dimension(0:3) :: pos
    real(dp), dimension(1:7) :: pot
    ! Index convention:
    !   pot: {1: V, 2: W, 3: X, 4: Y, 5: Z, 6: At, 7: Aph}
    real(dp) :: t,r,th,ph
    t=pos(0); r=pos(1); th=pos(2); ph=pos(3)"$

code3 :
"  end function
  function get_deriv_potential(pos) result(dpot)
    real(dp), dimension(0:3) :: pos
    real(dp), dimension(1:5,1:2) :: dpot
    ! Index convention:
    !   dpot, first index:
    !     {1: V, 2: W, 3: X, 4: Y, 5: Z}
    !   dpot, second index: (variable w.r.t. which we differentiate)
    !     {1: r, 2: th}
    real(dp) :: t,r,th,ph
    t=pos(0); r=pos(1); th=pos(2); ph=pos(3)"$

code4 :
"  end function
  function get_electromagnetic_potential(pos) result(empot)
    real(dp), dimension(0:3) :: pos
    real(dp), dimension(1:2) :: empot
    ! Index convention:
    !   empot: {1: At, 2: Aph}
    real(dp) :: t,r,th,ph
    t=pos(0); r=pos(1); th=pos(2); ph=pos(3)"$

code5 :
"  end function
  function get_deriv_electromagnetic_potential(pos) result(dempot)
    real(dp), dimension(0:3) :: pos
    real(dp), dimension(1:2,1:2) :: dempot
    ! Index convention:
    !   dempot, first index:
    !     {1: At, 2: Aph}
    !   dempot, second index: (variable w.r.t. which we differentiate)
    !     {1: r, 2: th}
    real(dp) :: t,r,th,ph
    t=pos(0); r=pos(1); th=pos(2); ph=pos(3)"$

code6 :
"  end function
end module
"$




/*
write_pot_fortran()
  Writes the potentials, derivs, and Fem1 to the following files:
    [metric_name]-pot.f90   : the potentials
    [metric_name]-dpot.f90  : the derivatives of the potentials
    [electromagneticpotential_name]-empot.f90  : the electromagnetic potentials
    [electromagneticpotential_name]-dempot.f90 : the derivatives of the electromagnetic potentials
    [electromagneticpotential_name]-fem.f90   : the electromagnetic tensor Fem1
    [metric_name]-param.f90 : the list of parameters (only def. of vars.)
    [electromagneticpotential_name]-param.f90 : the list of parameters (only def. of vars.)
    [metric_name].f90       : a Fortran module named [metric_name], with functions
                              to access the potentials, their derivatives, and Fem1.
    [electromagneticpotential_name].f90       : a Fortran module named [electromagneticpotential_name], with functions
                              to access the potentials, their derivatives, and Fem1.
*/

write_pot_fortran() := block(
  pot_func: [pv, pw, px, py, pz],
  dpot_dr: [0,0,0,0,0],
  dpot_dth: [0,0,0,0,0],

  empot_func: [At, Aph],
  dempot_dr: [0,0],
  dempot_dth: [0,0],

  for i thru 5 do(
    dpot_dr[i]:  diff(pot_func[i],r),
    dpot_dth[i]: diff(pot_func[i],th)
  ),
  
  for i thru 2 do(
    dempot_dr[i]:  diff(empot_func[i],r),
    dempot_dth[i]: diff(empot_func[i],th)
  ),

  load("f90"),

  with_stdout( sconcat(dir,metric_name,"-pot.f90"),
    for i thru 5 do(
      f90( pot(i) = pot_func[i] )
    )
  ),

  with_stdout( sconcat(dir,metric_name,"-dpot.f90"),
    for i thru 5 do(
      f90( dpot(i,1) = dpot_dr[i] ),
      f90( dpot(i,2) = dpot_dth[i] )
    )
  ),

  with_stdout( sconcat(dir,electromagneticpotential_name,"-empot.f90"),
    for i thru 2 do(
      f90( empot(i) = empot_func[i] )
    )
  ),

  with_stdout( sconcat(dir,electromagneticpotential_name,"-dempot.f90"),
    for i thru 2 do(
      f90( dempot(i,1) = dempot_dr[i] ),
      f90( dempot(i,2) = dempot_dth[i] )
    )
  ),

  with_stdout( sconcat(dir,metric_name,".f90"),
    print(sconcat("module ",metric_name)),
    print(code1),
    print(sconcat("  include \"",metric_name,"-param.f90","\"")),
    print(code2),
    print(sconcat("    include \"",metric_name,"-pot.f90","\"")),
    print(code3),
    print(sconcat("    include \"",metric_name,"-dpot.f90","\"")),
    print(code4),
    print(sconcat("    include \"",electromagneticpotential_name,"-empot.f90","\"")),
    print(code5),
    print(sconcat("    include \"",electromagneticpotential_name,"-dempot.f90","\"")),
    print(code6)
   ),

   print("Done (if no errors)."),
   print("Remember to check that real quantities are treated as double precision!
   If necessary, run the python script f90-single2double.py to make the conversion")

)$
