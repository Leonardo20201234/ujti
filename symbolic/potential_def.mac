/*-----------------------------------------------------------------------------
Writing of potentials, their derivatives, and electromagnetic tensor Fem1
to fortran source code
------------------------------------------------------------------------------*/

print("
--- -- -- -- ---._      UJTI - general geodesic ray-tracer
                o `.                                   o     _
                    \\          Cinespa UCR 2019  *  ( ) GANDREOLIVA.org
=======================================================================
  Symbolic metric in Maxima --> Potentials, derivatives, and Fem1
  for the Fortran numeric modules.
-----------------------------------------------------------------------
")$

print("Coordinate names: t,r,th,ph,")$
print("Potential names: pv,pw,px,py,pz,At,Ar,Ath,Aph")$
print("The potentials can only depend on r and th")$
print("Parameters: put (lowercase) symbols in a list called metric_parameters")$
print("Name of the metric : metric_name")$
print("Name of the electromagnetic potential : em_name")$
print("Output dir: dir (default: '', working directory)")$
print("-----------------------------------------------------------------------")$

dir : "" $

/* Fortran code that wraps up the metric potentials, derivs, and Fem1 in a module */

code1 :
" use, intrinsic :: iso_fortran_env, dp=>real64
 implicit none"$

code2 :
"  save
contains
  function get_potential(pos) result(pot)
    real(dp), dimension(0:3) :: pos
    real(dp), dimension(1:5) :: pot
    ! Index convention:
    !   pot: {1: V, 2: W, 3: X, 4: Y, 5: Z}
    real(dp) :: t,r,th,ph
    t=pos(0); r=pos(1); th=pos(2); ph=pos(3)"$

code3 :
"  end function
  function get_deriv_potential(pos) result(dpot)
    real(dp), dimension(0:3) :: pos
    real(dp), dimension(1:5,1:2) :: dpot
    ! Index convention:
    !   dpot, first index:
    !     {1: V, 2: W, 3: X, 4: Y, 5: Z}
    !   dpot, second index: (variable w.r.t. which we differentiate)
    !     {1: r, 2: th}
    real(dp) :: t,r,th,ph
    t=pos(0); r=pos(1); th=pos(2); ph=pos(3)"$

code4 :
"  end function
  function get_electromagnetic_potential(pos) result(empot)
    real(dp), dimension(0:3) :: pos
    real(dp), dimension(1:4) :: empot
    ! Index convention:
    !   empot: {1: At, 2: Ar, 3:Ath, 4:Aph}
    real(dp) :: t,r,th,ph
    t=pos(0); r=pos(1); th=pos(2); ph=pos(3)"$

code5 :
"  end function
  function get_deriv_electromagnetic_potential(pos) result(dempot)
    real(dp), dimension(0:3) :: pos
    real(dp), dimension(1:4,1:4) :: dempot
    ! Index convention:
    !   dempot, first index:
    !     {1: At, 2: Ar, 3: Ath, 4: Aph}
    !   dempot, second index: (variable w.r.t. which we differentiate)
    !     {1: t, 2: r, 3: th, 4: ph}
    real(dp) :: t,r,th,ph
    t=pos(0); r=pos(1); th=pos(2); ph=pos(3)"$

code6 :
"  end function
end module
"$


/*
write_metric_fortran()
  Writes only the metric potentials and their derivatives to files
*/

write_metric_fortran() := block(
  if not stringp(metric_name) then (
    print("Error: metric_name must be defined as a string"),
    return(false)
  ),
  
  pot_func: [pv, pw, px, py, pz],
  dpot_dr: [0,0,0,0,0],
  dpot_dth: [0,0,0,0,0],

  for i thru 5 do(
    dpot_dr[i]:  diff(pot_func[i],r),
    dpot_dth[i]: diff(pot_func[i],th)
  ),

  load("f90"),

  with_stdout( sconcat(dir,metric_name,"-pot.f90"),
    for i thru 5 do(
      f90( pot(i) = pot_func[i] )
    )
  ),

  with_stdout( sconcat(dir,metric_name,"-dpot.f90"),
    for i thru 5 do(
      f90( dpot(i,1) = dpot_dr[i] ),
      f90( dpot(i,2) = dpot_dth[i] )
    )
  ),

  with_stdout( sconcat(dir,metric_name,"-param.f90"),
    if listp(metric_parameters) then
      for p in metric_parameters do(
        print(sconcat("  real(dp) :: ",p))
      )
  ),

  with_stdout( sconcat(dir,metric_name,".f90"),
    print(sconcat("module ",metric_name)),
    print(code1),
    print(sconcat("  include \"",metric_name,"-param.f90","\"")),
    print(code2),
    print(sconcat("    include \"",metric_name,"-pot.f90","\"")),
    print(code3),
    print(sconcat("    include \"",metric_name,"-dpot.f90","\"")),
    print("  end function"),
    print("end module")
  ),

  print("Metric files written successfully."),
  print("Remember to check that real quantities are treated as double precision!")
)$


/*
write_em_fortran()
  Writes only the electromagnetic potentials and their derivatives to files
*/

write_em_fortran() := block(
  if not stringp(em_name) then (
    print("Error: em_name must be defined as a string"),
    return(false)
  ),
  
  empot_func: [At, Ar, Ath, Aph],
  dempot_dt: [0,0,0,0],
  dempot_dr: [0,0,0,0],
  dempot_dth: [0,0,0,0],
  dempot_dph: [0,0,0,0],

  for i thru 4 do(
    dempot_dt[i]:  diff(empot_func[i],t),
    dempot_dr[i]:  diff(empot_func[i],r),
    dempot_dth[i]: diff(empot_func[i],th),
    dempot_dph[i]: diff(empot_func[i],ph)
  ),

  load("f90"),

  with_stdout( sconcat(dir,em_name,"-empot.f90"),
    for i thru 4 do(
      f90( empot(i) = empot_func[i] )
    )
  ),

  with_stdout( sconcat(dir,em_name,"-dempot.f90"),
    for i thru 4 do(
      f90( dempot(i,1) = dempot_dt[i] ),
      f90( dempot(i,2) = dempot_dr[i] ),
      f90( dempot(i,3) = dempot_dth[i] ),
      f90( dempot(i,4) = dempot_dph[i] )
    )
  ),

  with_stdout( sconcat(dir,em_name,"-param.f90"),
    if listp(em_parameters) then
      for p in em_parameters do(
        print(sconcat("  real(dp) :: ",p))
      )
  ),

  with_stdout( sconcat(dir,em_name,".f90"),
    print(sconcat("module ",em_name)),
    print(code1),
    print(sconcat("  include \"",em_name,"-param.f90","\"")),
    print("  save"),
    print("contains"),
    print(code4),
    print(sconcat("    include \"",em_name,"-empot.f90","\"")),
    print(code5),
    print(sconcat("    include \"",em_name,"-dempot.f90","\"")),
    print(code6)
  ),

  print("Electromagnetic potential files written successfully."),
  print("Remember to check that real quantities are treated as double precision!")
)$


/*
write_pot_fortran()
  Writes both metric and electromagnetic potentials (legacy function for compatibility)
*/

write_pot_fortran() := block(
  has_metric: stringp(metric_name),
  has_em: stringp(em_name),
  
  if not has_metric and not has_em then (
    print("Error: Either metric_name or em_name must be defined"),
    return(false)
  ),
  
  if has_metric then write_metric_fortran(),
  if has_em then write_em_fortran(),
  
  print("Done (if no errors).")
)$